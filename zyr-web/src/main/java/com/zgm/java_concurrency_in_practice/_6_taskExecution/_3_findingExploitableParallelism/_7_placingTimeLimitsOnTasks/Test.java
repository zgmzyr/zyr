/*
 * Copyright 2013 The JA-SIG Collaborative. All rights reserved.
 * distributed with this file and available online 
 */
package com.zgm.java_concurrency_in_practice._6_taskExecution._3_findingExploitableParallelism._7_placingTimeLimitsOnTasks;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;


/**
 * 
 * @author 周光明 Exp
 * @version $FileName: Test.java $Date: May 20, 2013 10:19:14 AM -0400 2013
 * @since 1.0
 * 
 */
public class Test {
    private static final long TIME_BUDGET = 5;
	private static final TimeUnit NANOSECONDS = TimeUnit.NANOSECONDS;
	private static final Ad DEFAULT_AD = new Ad();
	
	public Test(ExecutorService executor) {
		super();
		this.executor = executor;
	}

	private final ExecutorService executor;
    
	Page renderPageWithAd() throws InterruptedException {
		long endNanos = System.nanoTime() + TIME_BUDGET;
		Future<Ad> f = executor.submit(new FetchAdTask<Ad>());
		// Render the page while waiting for the ad
		Page page = renderPageBody();
		Ad ad;
		try {
			// Only wait for the remaining time budget
			long timeLeft = endNanos - System.nanoTime();
			ad = f.get(timeLeft, NANOSECONDS);
		} catch (ExecutionException e) {
			ad = DEFAULT_AD;
		} catch (java.util.concurrent.TimeoutException e) {
			ad = DEFAULT_AD;
			e.printStackTrace();
		}
		
		page.setAd(ad);
		
		return page;
	}

	private Page renderPageBody() {
		//TODO
		return null;
	}

}
